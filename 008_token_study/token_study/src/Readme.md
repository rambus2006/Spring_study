## {비대칭키 암호화}
   키가 두개(공개키,개인키)이고, 
 - 공개키로 암호화하면 개인키로 복호화
 - 개인키로 암호화(=서명)하면 공개키로 복호화(=검증):아무나 열 수 있다. 
   - 개인키는 유출되지 않게 조심해야 한다. 
   - 두개를 키쌍으로 한다. 
 - 대칭키보다 계산량이 많아서 대량의 암호화에는 부적절하다.(속도가 느리다)
 - 비대칭키는 대칭키를 암호화해서 보내는데 자주 쓴다.
 - 개인키 == 인감도장 같은 역할<br>

### <알고리즘 종류 >
- RSA => 가장 널리 사용되는 알고리즘
- ECC (Elliptic Curve Cryptography) => 더 짧은 키로 높은 보안성 제공, 타원곡선공개 키
- DSA (Digital Signature Algorithm) => 주로 디지털 서명에 사용

## {전자서명}
- 원본 데이터를 해시하고, 개인키로 암호화한 바이트 배열을 원본데이터와 같이 보내기
- 원본 데이터 + (해시하고 개인키로 암호화한 바이트배열)(전자서명)
  (1)전자서명이 공개키로 풀렸다는 것은 해당 내용이 암호화한 사람이 개인키로 암호화한 것이 맞다는 걸 보증한다.
  (2)(1)의 결과로 해시값이 나오는데, 원본 데이터를 직접 해시값을 계산해본 후에 복호화한 해시값과 비교해서 
  같을 경우 => 데이터 조작이 없으니까 믿기 
  틀릴경우 => 데이터 조작O, 바로 거부 

-> 이것을 통해 개인키로 암호화 했고(1),조작되지 않은 데이터다(2)를 알 수 있다. 

---
2024-09-12
## {전자서명}
- 송신측 
  1. 원본 데이터 작성 
  2. 1의 데이터를 해시함수(SHA-256)을 적용해서 해시값을 얻음
  3. 2의 해시값을 개인키를 이용해서 암호화(=서명)한 데이터를 얻음 
  4. 1+4의 데이터를 수신처로 전달
<br>
- 수신측
  1. 전달받은 데이터를 원본 데이터와 암호화(=서명)데이터로 분리 
  2. 암호화 데이터를 송신측의 개인키로 복호화(=검증)
  -> 여기서 실패하면? 송신측의 개인키로 서명한 내용이 아니므로 메시지 버리ㅐ기
  3. 암호화데이터에 저장된 해시값을 추출
  4. 원본 데이터에 똑같은 해시함수를 적용하여 그값을 추출한 해시값과 비교
  -> 여기서 일치하지 않으면 원본 데이터가 조작되었으므로 메시지 버리기 
  5. 메시지 수용

## {JWT}
- 롯데월드 같은 입장권인데 그 중에서 vip인지, 일반이용권인지
- 헤더, 페이로드, 서명으로 나눌 수 있다. 
- JSON Web Token (JWT)은 당사자 간에 정보를 안전하게 전송하기 위한 컴팩트하고 독립적인 방식을 정의하는 개방형 표준(RFC 7519)
<br>
<br>
- 인증 (Authentication)
  - 사용자가 로그인하면 서버는 사용자 정보를 바탕으로 JWT를 발급
  - 사용자는 이 토큰을 클라이언트에 저장해서 이후 인증이 필요한 요청 시 사용
  - 서버는 수신한 토큰을 확인하여 사용자를 인증(=검증)
- 권한 부여 (Authorization)
  - JWT는 사용자가 접근할 리소스나 행위에 대한 권한 정보를 포함
  - 서버는 요청받은 리소스에 대한 접근 권한이 있는지 JWT를 통해 확인 가능
- 무상태 
  - 상태를 서버가 가지고 있어야 한다. 
  - 적법한 상태인지만 확인(올바르게 발급된 건지만 확인)

## {부분별}
- 사용한 사이트 
    
    https://jwt.io/
    <br/>
    https://www.base64decode.org/

### <헤더>
```
{
"alg": "HS256", //알고리즘
"typ": "JWT" //타입
}
```
### <페이로드>
- 주 내용을 담는 부분
```
{
"sub": "1234567890", //아이디
"name": "John Doe", //이름
"iat": 1516239022 //유닉스 타임 (1970년 기준으로 초세는 단위)
}
```
### <서명 >
- 암호화된 바이트 배열
```
IJIHǊ(]Oǉ~:N%_u,×
```

## {코드}
```
{
  "iss": "https://auth.example.com",
  "sub": "1234567890",
  "aud": "https://api.example.com",
  "exp": 1516239022,
  "nbf": 1516238022,
  "iat": 1516238022,
  "jti": "a-123",
  "name": "John Doe",
  "email": "johndoe@example.com",
  "roles": ["ROLE_USER"],
  "permissions": ["read", "write"],
  "custom_claim": "custom value"
}
```
exp:토큰의 만료일 
nbf: 어떤 시점의 이후에 토큰을 사용할 수 있을 때 쓰는 옵션 
iat: 발급일 
jti: 토큰의 아이디를 준 값 
roles:권한 
roles:관리자 권한을 준다. (수정,삭제,쓰기,읽기 권한을 다 줄 수 있다.)
permission: 권한을 더 세밀하게 줄 수 있다. 어떤 사람에게는 수정권한만 준다/ 어떤 사람에게는 삭제 권한만 줄 수 있다. 

## {HMACwithSHA256}
- HMAC(hash-based message authentication code)
- 해시 기반의 "서명" 알고리즘
- 전자서명만 하기 위해 태어남 
- 암호화복호화는 못함.
- 원본 데이터 + 비밀키 => 해시값 => MAC 코드가 된다. 
