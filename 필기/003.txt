Bean 이란? => 중요한 객체인데, ApplicationContext 에 보관 
Bean 으로 만들기 위해서 사용하는 대표적인 어노테이션은 ?
@Component, @Service, @Repository,...
@ComponentScan의 역할?
특정 패키지와 하위 패키지의 모든 Bean 검사해서 생성해서 보관 

@Configuration 어노테이션 왜 쓰는지?
메서드 레벨에서 Bean을 생성해서 반환하고 싶어서 
Bean 이 기본 생성자 호출로 만들기 어려운 경우 

@Autowired 어노테이션 왜 쓰는지? 
의존성 주입을 하기 위해서 

의존성 주입 세가지 방법? 
생성자 인젝션(*) , 필드 인젝션, 세터 인젝션 

@Primary나 @Qualifer같은 어노테이션을 쓰는 이유?
의존성 주입을 하려고 하는데 , 주입해야 할 Bean 객체 후보가 2개 이상인 경우, 
어떤 Bean을 주입할지 직접적으로 명시해야 할 필요성 

@primary : 이게 더 좋다고 표시하는 경우  
@Qualifer : 내가 직접 Bean을 정해주는 것 

----------------------------------------------------------------------------
{ 98_HTTP 프로토콜(기초) }
* 모든 웹서버 프로토콜에서 쓰이는 이론이다. 
- Http를 이해할 때 요청메시지와 응답 메시지 데이터밖에 없다. 구조만 파악하면 된다. 
- 요청메시지는 3개의 영역으로 구분되는데, 시작줄, 헤더영역, 바디영역으로 나뉜다. 
  * 헤더영역이 가장 중요하다. 
- 개행문자(CR+LF)를 이용하여 구분한다. (Ente가 아닌 cr과 lf 이 두가지 문자가 포함된 엔터로 구분된다.) 

<요청메시지형식>
(HTTP메소드) (Path) (HTTP버전)
GET /hello HTTP/1.1
Get 메서드, 어떤 데이터를 요청하는 것,데이터를 가져올 때 쓰는 것이기 때문에 바디가 없는 경우가 많다. 
hello HTTP/1.1
1.1 - HTTP 의 버전을 사용한다. 일반적으로 1.1을 많이 사용한다. 옛날 문서만 나오는 게 버전 1.0

Host: www.example.com - post라고 하는 헤더 
key : value 이게 헤더 1개이다. 

<응답 메시지형식>
요청온 버전과 같아야 한다. 
>형식 
시작줄 - 헤더영역 - 바디영역 
(HTTP버전) (상태코드) (상태메시지)
HTTP/1.1 200 OK
- 상태 코드와 상태 메시지는 세트라고 보면 된다. 상태 메시지는 상태 코드에 따라 정해진다. 
- 바디 영역
응답 메시지라면 일반적으로 바디 내용을 포함하지만 의무사항은 아님





















